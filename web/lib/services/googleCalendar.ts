import { google } from 'googleapis'
import { supabase } from '../supabase'
import type { GoogleCalendarToken } from '../types/database'

const oauth2Client = new google.auth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI
)

const SCOPES = [
  'https://www.googleapis.com/auth/calendar.readonly',
  'https://www.googleapis.com/auth/calendar.events',
]

export interface GoogleCalendarEvent {
  id: string
  summary: string
  description?: string
  start: {
    dateTime?: string
    date?: string
    timeZone?: string
  }
  end: {
    dateTime?: string
    date?: string
    timeZone?: string
  }
}

export const googleCalendarService = {
  // Generate OAuth URL for user to authorize
  getAuthUrl(userId: string): string {
    return oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: SCOPES,
      prompt: 'consent',
      state: userId, // Pass user ID to callback
    })
  },

  // Exchange authorization code for tokens
  async exchangeCodeForTokens(code: string): Promise<{
    access_token: string
    refresh_token: string
    expiry_date: number
  }> {
    const { tokens } = await oauth2Client.getToken(code)
    return {
      access_token: tokens.access_token!,
      refresh_token: tokens.refresh_token!,
      expiry_date: tokens.expiry_date!,
    }
  },

  // Save tokens to database
  async saveTokens(
    userId: string,
    accessToken: string,
    refreshToken: string,
    expiryDate: number
  ): Promise<void> {
    const { error } = await supabase
      .from('google_calendar_tokens')
      .upsert({
        user_id: userId,
        access_token: accessToken,
        refresh_token: refreshToken,
        token_expiry: new Date(expiryDate).toISOString(),
        updated_at: new Date().toISOString(),
      }, {
        onConflict: 'user_id',
      })

    if (error) throw error
  },

  // Get user's tokens from database
  async getTokens(userId: string): Promise<GoogleCalendarToken | null> {
    const { data, error } = await supabase
      .from('google_calendar_tokens')
      .select('*')
      .eq('user_id', userId)
      .single()

    if (error && error.code !== 'PGRST116') throw error
    return data as GoogleCalendarToken | null
  },

  // Check if user has connected Google Calendar
  async isConnected(userId: string): Promise<boolean> {
    const tokens = await this.getTokens(userId)
    return tokens !== null
  },

  // Delete user's Google Calendar connection
  async disconnect(userId: string): Promise<void> {
    const { error } = await supabase
      .from('google_calendar_tokens')
      .delete()
      .eq('user_id', userId)

    if (error) throw error
  },

  // Refresh access token if expired
  async refreshAccessToken(userId: string): Promise<string> {
    const tokens = await this.getTokens(userId)
    if (!tokens) throw new Error('No Google Calendar tokens found')

    const tokenExpiry = new Date(tokens.token_expiry)
    const now = new Date()

    // If token is still valid, return it
    if (tokenExpiry > now) {
      return tokens.access_token
    }

    // Refresh the token
    oauth2Client.setCredentials({
      refresh_token: tokens.refresh_token,
    })

    const { credentials } = await oauth2Client.refreshAccessToken()

    // Save new tokens
    await this.saveTokens(
      userId,
      credentials.access_token!,
      tokens.refresh_token, // Keep the original refresh token
      credentials.expiry_date!
    )

    return credentials.access_token!
  },

  // Get authenticated calendar client
  async getCalendarClient(userId: string) {
    const accessToken = await this.refreshAccessToken(userId)
    oauth2Client.setCredentials({ access_token: accessToken })
    return google.calendar({ version: 'v3', auth: oauth2Client })
  },

  // Read events from Google Calendar for a specific date
  async getEvents(userId: string, date: string): Promise<GoogleCalendarEvent[]> {
    const calendar = await this.getCalendarClient(userId)
    const tokens = await this.getTokens(userId)
    const calendarId = tokens?.calendar_id || 'primary'

    // Get start and end of day in user's timezone
    const startOfDay = new Date(date)
    startOfDay.setHours(0, 0, 0, 0)
    const endOfDay = new Date(date)
    endOfDay.setHours(23, 59, 59, 999)

    const response = await calendar.events.list({
      calendarId,
      timeMin: startOfDay.toISOString(),
      timeMax: endOfDay.toISOString(),
      singleEvents: true,
      orderBy: 'startTime',
    })

    return (response.data.items || []) as GoogleCalendarEvent[]
  },

  // Create event in Google Calendar
  async createEvent(
    userId: string,
    title: string,
    date: string,
    startTime: string,
    endTime: string,
    description?: string
  ): Promise<GoogleCalendarEvent> {
    const calendar = await this.getCalendarClient(userId)
    const tokens = await this.getTokens(userId)
    const calendarId = tokens?.calendar_id || 'primary'

    // Format times for Google Calendar
    const startDateTime = `${date}T${startTime}`
    const endDateTime = `${date}T${endTime}`

    const response = await calendar.events.insert({
      calendarId,
      requestBody: {
        summary: title,
        description,
        start: {
          dateTime: startDateTime,
          timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
        end: {
          dateTime: endDateTime,
          timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
      },
    })

    return response.data as GoogleCalendarEvent
  },

  // Update event in Google Calendar
  async updateEvent(
    userId: string,
    googleEventId: string,
    updates: {
      title?: string
      description?: string
      startTime?: string
      endTime?: string
      date?: string
    }
  ): Promise<GoogleCalendarEvent> {
    const calendar = await this.getCalendarClient(userId)
    const tokens = await this.getTokens(userId)
    const calendarId = tokens?.calendar_id || 'primary'

    const requestBody: Record<string, unknown> = {}
    if (updates.title) requestBody.summary = updates.title
    if (updates.description) requestBody.description = updates.description
    if (updates.startTime && updates.date) {
      requestBody.start = {
        dateTime: `${updates.date}T${updates.startTime}`,
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      }
    }
    if (updates.endTime && updates.date) {
      requestBody.end = {
        dateTime: `${updates.date}T${updates.endTime}`,
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      }
    }

    const response = await calendar.events.patch({
      calendarId,
      eventId: googleEventId,
      requestBody,
    })

    return response.data as GoogleCalendarEvent
  },

  // Delete event from Google Calendar
  async deleteEvent(userId: string, googleEventId: string): Promise<void> {
    const calendar = await this.getCalendarClient(userId)
    const tokens = await this.getTokens(userId)
    const calendarId = tokens?.calendar_id || 'primary'

    await calendar.events.delete({
      calendarId,
      eventId: googleEventId,
    })
  },
}
